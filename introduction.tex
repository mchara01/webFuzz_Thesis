\chapter{Introduction}
\pagenumbering{arabic} % start arabic page numbering
\minitoc
\vspace*{1cm}

This the first and introductory chapter of this thesis. Here we analyse what motivated us to do research in the area of grey-box fuzzing and start this project, any related work regarding this area, the contribution that this thesis makes and the outline of the topics of the chapters included in this thesis.

% NEW SECTION
\section{Motivation}
Fuzzing is now recognised as an essential process for discovering hidden bugs in computer software. Automated software testing or fuzzing is a tried and tested method of generating or mutating inputs and passing them to programs in search of bugs. The spark in the fuzzing 'revolution' to discover bugs in software in an automated fashion has been precipitated with the introduction of AFL ~\cite{zalewski2015american}, a state-of-the-art fuzzer that produces feedback during fuzzing by leveraging instrumentation of the analysed program. By creating this \textit{feedback loop}, fuzzers can significantly improve their performance as they can determine whether an input is interesting, namely it triggers a new code path, and uses that input to produce other test cases.

Software testing plays a vital role in the software development cycle because when vulnerabilities are present, they can have severe and even irreparable consequences. By exploiting software bugs, adversaries can perform data breaches, install malicious malware or even take complete control of a device. Detecting bugs before they get exploited is possible while also being a demanding task. Mainly because bugs are triggered when an unexpected input is given to the program, something which is difficult to fully simulate through statically written unit tests. This is because unit tests usually revolve around expected inputs in order to test the intended functionality of code ~\cite{aschermann2019nautilus}.

Although automated software testing has become an attractive field of research, it still has a long way to go, especially for web applications ~\cite{doupe2010johnny}. As the Internet infrastructure expands, more software that is written in native code(precompiled program in the CPU's machine language) is migrating to web applications. This attracts more malicious attacks on web applications. Hence, there is a strong need for the development of automated vulnerabilities scanners that target web applications.
 
% NEW SECTION REPHRASE
\section{Related Work}
 Numerous fuzzers recently developed try to optimize the fuzzing process by proposing various methodologies ~\cite{godefroid2012sage, stephens2016driller, rawat2017vuzzer, aschermann2019nautilus, aschermann2019redqueen, hoffman2020Was, osterlund2020parmesan}. For example, most of the fuzzers take advantage of instrumentation on the binary or source level. That is, inserting code to the program in order to receive feedback when a code block gets
triggered and try to adjust the generated inputs to improve code coverage. Others utilize symbolic/concolic execution for extracting useful information about the program and use that information for improving the input generation process ~\cite{stephens2016driller,godefroid2005dart,godefroid2012sage}. However, all these fuzzers are currently targeted towards finding vulnerabilities in native code, while web applications have received limited attention. More related work will be see again at Chapter ~\ref{sec:relatedwork}.

\section{Contributions}
In this thesis, \pname{} is proposed. It is a prototype grey-box fuzzing tool for web applications. Today, the only fuzzers available for web applications are developed to behave in a black-box fashion ~\cite{doupe2010johnny}. This is to say they use brute force to bombard their targets with URLs that embed known web-attack payloads. Recently there where breakthroughs with white-box fuzzing also ~\cite{navex2018,Borges2018BaZINGAWF}. On the contrary, \pname{} initially instruments the targeted web application by adding code that tracks all control flows triggered by an input and notifies the fuzzer, accordingly. Notifications can be embedded in the web application's HTTP response using custom headers or outputted to a shared log file or memory region. Subsequently, the fuzzer begins sending requests to the target and analyses the responses to detect any interesting requests that would later help to improve the code coverage and as a result, trigger vulnerabilities embedded deep in the web application's code.

The following contributions are made in this thesis:

\begin{enumerate}

\item We design, implement and evaluate \pname{}, the first grey-box fuzzer realized for discovering vulnerabilities in web applications. \pname{} applies instrumentation on the target web application for guiding the entire fuzzing process. Instrumentation can be applied on the AST level of PHP-based web applications for creating a feedback loop and utilizing it in order to increase code coverage.
\item We thoroughly evaluate \pname{} in terms of coverage, throughput and efficiency in finding unknown bugs. For better understanding the measured capabilities of \pname{} we compare our results with three existing web-application fuzzers. \pname{} is the only fuzzer that
reports coverage information; in particular, \pname{} can cover about 21.5\% of the entire WordPress code, which contains around half a million LoCs, in 50 hours of fuzzing. As expected, \pname{} is slower, in terms of throughput, due to the involved instrumentation. In fact, another popular fuzzer, Wfuzz ~\cite{wfuzz} is three times faster when fuzzing Drupal, but this is something to be expected, since the reduction of the throughput due to the instrumentation pays off in increased coverage in the long run. Finally, \pname{}, compared to the other three fuzzers, finds the most injected vulnerabilities (30 with the second one being Wfuzz with 28) for a fuzzing session that lasts 65 hours. The evaluation of \pname{} can be seen in detail in Chapter ~\ref{sec:evaluation}
\item To foster further research in the field, \pname{} is release as open source.

\end{enumerate}

\section{Thesis Outline}
The thesis consist of eight chapters. In the first chapter we present the incentive of this thesis, any related work on the topic and the contributions of this thesis. In the second chapter we state any relevant background information required to grasp the perspective of this thesis. Continuing to the third chapter, the architecture of the tool is discussed on a higher level without delving into too much implementation details. The fourth chapter is dedicated for discussing the technical aspects of the fuzzing tool developed. The fifth chapter consists of the evaluation to see how well \pname{} performs in terms of finding bugs, code coverage and throughput against other fuzzers. In the sixth chapter, a discussion is included that consist of the limitation faced during the process and any future plans we have for our tool. In the seventh chapter we elaborate on the related work made in the area of fuzzing over the years. In the eight and final chapter we give our conclusion.
