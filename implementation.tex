\chapter{Implementation}
\label{sec:implementation}
\minitoc
\vspace*{1cm}

In this section, we discuss the technical aspects, some of
the key characteristics that constitute \pname{} and the way
we deployed our WordPress application using containers to
evaluate our fuzzer’s performance.


% NEW SECTION
\section{Coding Standards}
As Guido van Rossum(known as the creator of the Python programming language) said, "Code is read much more often than it is written". For this reason, throughout the course of this thesis, the aim was to write clear and readable code, as all professional tools do. For this, we enforced the latest conventions, as recommended from the Python community, in order to enforce maintainability, clarity, consistency, and generally, a foundation for good programming habits and practices. More specifically, our fuzzing tool is fully written in Python 3 using the PEP 8 ~\cite{python_pep8} coding style standard and, for documentation, the PEP 257 ~\cite{python_pep257} docstring convention was used so it will be clear and easy to read from programmers. Pylint ~\cite{pylint_module} was used to check for errors in Python code and try to enforce the aforementioned coding standards and look for code smells.

Furthermore, to add on the good practises mentioned, unit tests where also created through which individual modules of the tool's source code are put under various tests to determine a particular unit's correctness and whether they are fit for use. More precisely, parts of the application's code are validated by using test cases that stress test the tool and ascertain the quality of your code by checking it against the expected response. For this part, popular python test frameworks where used like pytest ~\cite{pytest_module}, unittest ~\cite{unittest_module} and mock ~\cite{mock}. In the appendix, an example of unit testing for the parser module can be found.


% NEW SECTION
\section{Asyncio}

 
Asyncio, on the other hand, uses cooperative multitasking. The tasks must cooperate by announcing when they are ready to be switched out. The benefit of doing this extra work up front is that you always know where your task will be swapped out.
It will not be swapped out in the middle of a Python statement unless that statement is marked. 

will be downloading web pages from a few sites, creating a Session object allows requests to do some fancy networking tricks and really speed things up.
 OUR FUZZER IS CONSIDER AN I/O BOUND PROGRAM.
 
 The general concept of asyncio is that a single Python object, called the event loop, controls how and when each task gets run. The event loop is aware of each task and knows what state it's in. In reality, there are many states that tasks could be in, but for now let's imagine a simplified event loop that just has two states. The ready state will indicate that a task has work to do and is ready to be run, and the waiting state means that the task is waiting for some external thing to finish, such as a network operation. Your simplified event loop maintains two lists of tasks, one for each of these states. It selects one of the ready tasks and starts it back to running. That task is in complete control until it cooperatively hands the control back to the event loop. When the running task gives control back to the event loop, the event loop places that task into either the ready or waiting list and then goes through each of the tasks in the waiting list to see if it has become ready by an I/O operation completing. It knows that the tasks in the ready list are still ready because it knows they haven't run yet. An important point of asyncio is that the tasks never give up control without intentionally doing so. They never get interrupted in the middle of an operation. 
 
 you can view await as the magic that allows the task to hand control back to the event loop.  code awaits a function call, it's a signal that the call is likely to be something that takes a while and that the task should give up control.
(async with aiohttp.ClientSession() as session:) You can share the session across all tasks, so the session is created here as a context manager. The tasks can share the session because they are all running on the same thread. Each task takes far fewer resources and less time to create than a thread, so creating and running more of them works well. This example just creates a separate task for each site to download, which works out quite well.

 Remember that any task that doesn't give up control to the event loop will block all of the other tasks.
 
 
 
Asynchronous routines are able to "pause" while waiting on their ultimate result and let other routines run in the meantime. Asynchronous code, through the mechanism above, facilitates concurrent execution. So, cooperative multitasking is a fancy way of saying that a program's event loop (more on that later) communicates with multiple tasks to let each take turns running at the optimal time. Async IO takes long waiting periods in which functions would otherwise be blocking and allows other functions to run during that downtime. (A function that blocks effectively forbids others from running from the time that it starts until the time that it returns. Python's async model is built around concepts such as callbacks, events, transports, protocols, and futures just the terminology can be intimidating.
At the heart of async IO are coroutines. A coroutine is a specialized version of a Python generator function. a coroutine is a function that can suspend its execution before reaching return, and it can indirectly pass control to another coroutine for some time. The syntax async def introduces either a native coroutine or an asynchronous generator. it is a SyntaxError to use await outside of an async def coroutine. You can only use await in the body of coroutines. Finally, when you use await f(), it's required that f() be an object that is awaitable. Well, that’s not very helpful, is it? For now, just know that an awaitable object is either (1) another coroutine or (2) an object defining an .__await__() dunder method that returns an iterator.await is the asyncio equivalent of joining a thread.  create_task starts task in the background. The await keyword behaves similarly, marking a break point at which the coroutine suspends itself and lets other coroutines work. "Suspended," in this case, means a coroutine that has temporarily ceded control but not totally exited or finished. The use of await is a signal that marks a break point - It lets a coroutine temporarily suspend execution and permits the program to come back to it later.
You can think of an event loop as something like a while True loop that monitors coroutines, taking feedback on what's idle, and looking around for things that can be executed in the meantime. It is able to wake up an idle coroutine when whatever that coroutine is waiting on becomes available. asyncio.run(), introduced in Python 3.7, is responsible for getting the event loop, running tasks until they are marked as complete, and then closing the event loop.
 aiohttp, a blazingly fast async HTTP client/server framework. You may be wondering why Python's requests package isn't compatible with async IO. requests is built on top of urllib3, which in turn uses Python's http and socket modules.By default, socket operations are blocking. This means that Python won't like await requests.get(url) because .get() is not awaitable. In contrast, almost everything in aiohttp is an awaitable coroutine, such as session.request() and response.text(). 
 
\section{Testing Model}
For Python, PEP 8 has emerged as the style guide that most projects adhere to; it promotes a very readable and eye-pleasing coding style. https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists


grapse giaa to argparser

One example of white-box testing is called unit testing, which concentrates
on testing each of the functions as you see them in the code.

Logging is a module in the Python standard library that provides a richly-formatted log with a flexible filter and the possibility to redirect logs to other sources such as syslog or email.
